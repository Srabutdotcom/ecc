const SHA3_ROTL=[1,3,6,10,15,21,28,36,45,55,2,14,27,41,56,8,25,43,62,18,39,61,20,44],SHA3_PI=[20,14,22,34,36,6,10,32,16,42,48,8,30,46,38,26,24,4,40,28,44,18,12,2],SHA3_IOTA_H=[1,32898,32906,2147516416,32907,2147483649,2147516545,32777,138,136,2147516425,2147483658,2147516555,139,32905,32771,32770,128,32778,2147483658,2147516545,32896,2147483649,2147516424],SHA3_IOTA_L=[0,0,2147483648,2147483648,0,0,2147483648,2147483648,0,0,0,0,0,2147483648,2147483648,2147483648,2147483648,2147483648,0,2147483648,2147483648,2147483648,0,2147483648],rotlSH=(t,s,e)=>t<<e|s>>>32-e,rotlSL=(t,s,e)=>s<<e|t>>>32-e,rotlBH=(t,s,e)=>s<<e-32|t>>>64-e,rotlBL=(t,s,e)=>t<<e-32|s>>>64-e,rotlH=(t,s,e)=>e>32?rotlBH(t,s,e):rotlSH(t,s,e),rotlL=(t,s,e)=>e>32?rotlBL(t,s,e):rotlSL(t,s,e);function keccakP(t,s=24){let e=new Uint32Array(10);for(let i=24-s;i<24;i++){for(let _=0;_<10;_++)e[_]=t[_]^t[_+10]^t[_+20]^t[_+30]^t[_+40];for(let h=0;h<10;h+=2){const o=(h+8)%10,$=(h+2)%10,n=e[$],r=e[$+1], l=rotlH(n,r,1)^e[o],u=rotlL(n,r,1)^e[o+1];for(let a=0;a<50;a+=10)t[h+a]^=l,t[h+a+1]^=u}let f=t[2],c=t[3];for(let p=0;p<24;p++){const d=SHA3_ROTL[p],k=rotlH(f,c,d),H=rotlL(f,c,d), A=SHA3_PI[p];f=t[A],c=t[A+1],t[A]=k,t[A+1]=H}for(let L=0;L<50;L+=10){for(let S=0;S<10;S++)e[S]=t[L+S];for(let O=0;O<10;O++)t[L+O]^=~e[(O+2)%10]&e[(O+4)%10]}t[0]^=SHA3_IOTA_H[i],t[1]^=SHA3_IOTA_L[i]}clean(e)}export function clean(...t){for(let s=0;s<t.length;s++)t[s].fill(0)}class SHA3{constructor(t=136,s=6,e,i=!1,_=24){this.rateBytes=t,this.blockLen=t,this.state=new Uint8Array(200),this.state32=new Uint32Array(this.state.buffer),this.pos=0,this.posOut=0,this.rounds=_,this.finished=!1,this.suffix=s,this.outputLen=e,this.enableXOF=i}keccak(){keccakP(this.state32,this.rounds),this.pos=0,this.posOut=0}update(t){for(let s=0;s<t.length;){let e=Math.min(this.blockLen-this.pos,t.length-s);for(let i=0;i<e;i++)this.state[this.pos++]^=t[s++];this.pos===this.blockLen&&this.keccak()}return this}finish(){this.finished||(this.finished=!0,this.state[this.pos]^=this.suffix,128&this.suffix&&this.pos===this.blockLen-1&&this.keccak(),this.state[this.blockLen-1]^=128,this.keccak())}writeInto(t){this.finish();let{state:s,blockLen:e}=this,i=0;for(;i<t.length;){this.posOut===e&&this.keccak();let _=Math.min(e-this.posOut,t.length-i);t.set(s.subarray(this.posOut,this.posOut+_),i),this.posOut+=_,i+=_}return t}xofInto(t){if(!this.enableXOF)throw Error("XOF not supported for this hash");return this.writeInto(t)}xof(t){return this.xofInto(new Uint8Array(t))}digestInto(t){if(this.finished)throw Error("digest() already called");return this.writeInto(t),this.destroy?.(),t}digest(){return this.digestInto(new Uint8Array(this.outputLen))}destroy(){this.state.fill(0),this.state32.fill(0),this.pos=this.posOut=0,this.finished=!0}}function shake256(t){let s=new SHA3(136,31,114);return s.update(t),s.digest()}function shake128(t){let s=new SHA3(168,31,64);return s.update(t),s.digest()}function sha3_256(t){let s=new SHA3(136,6,32);return s.update(t),s.digest()}function sha3_384(t){let s=new SHA3(104,6,48);return s.update(t),s.digest()}function sha3_512(t){let s=new SHA3(72,6,64);return s.update(t),s.digest()}export{shake256,shake128,sha3_256,sha3_384,sha3_512};